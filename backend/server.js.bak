const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const { authenticate } = require('./middleware/auth');

const app = express();

// Auth middleware
const authenticate = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ 
            success: false, 
            message: 'No authentication token provided' 
        });
    }

    const token = authHeader.split(' ')[1];
    if (!token || !token.startsWith('test-token-')) {
        return res.status(401).json({ 
            success: false, 
            message: 'Invalid authentication token' 
        });
    }

    // For demo, set a mock user ID
    req.user = { _id: '1', email: 'tanmaytr05@gmail.com', name: 'Test User' };
    next();
};

const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const { authenticate } = require('./middleware/auth');

const app = express();

// CORS configuration
app.use(cors({
    origin: 'http://localhost:3000',
    credentials: true,
    methods: ['GET', 'POST'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));

// Dashboard route handler
const handleDashboardRequest = async (req, res) => {
    let dbConnected = mongoose.connection.readyState === 1;
    
    try {
        if (!req.headers.accept?.includes('application/json')) {
            return res.status(406).json({
                success: false,
                message: 'Only JSON responses are supported'
            });
        }

        // Set caching headers
        res.set({
            'Cache-Control': 'private, max-age=5',  // Cache for 5 seconds
            'Expires': new Date(Date.now() + 5000).toUTCString(),
            'Vary': 'Authorization'  // Vary cache by auth token
        });

        // Get stats data (using mock data if DB is not connected)
        const stats = {
            totalProducts: dbConnected ? await Product.countDocuments() : 5,
            productViews: 120,
            recentOrders: dbConnected ? await Order.countDocuments() : 8,
            revenue: 15000
        };

        // Get recent orders (using mock data if DB is not connected)
        const orders = dbConnected 
            ? await Order.find().sort({ createdAt: -1 }).limit(10).lean()
            : [{
                _id: "order1",
                user: "John Doe",
                items: [{
                    product: {
                        name: "Premium Medical Kit",
                        _id: "prod1"
                    },
                    quantity: 2,
                    price: 2000
                }],
                totalAmount: 4000,
                status: "CONFIRMED",
                createdAt: new Date().toISOString(),
                paymentDetails: {
                    status: "PAID",
                    method: "CARD"
                }
            }];

        // Return data in the expected format
        return res.json({
            success: true,
            data: {
                stats,
                orders
            }
        });
    } catch (error) {
        console.error('Dashboard error:', error);
        return res.status(500).json({
            success: false,
            error: 'Internal server error',
            message: error.message
        });
    }
};

app.use(express.json());

// Dashboard endpoints - only keep the main one
app.get('/api/dashboard', authenticate, handleDashboardRequest);

// Health check endpoint with MongoDB connection status
app.get('/health', async (req, res) => {
    try {
        // Check MongoDB connection
        const isMongoConnected = mongoose.connection.readyState === 1;
        
        res.json({ 
            status: 'ok',
            message: 'Server is running',
            timestamp: new Date().toISOString(),
            database: {
                connected: isMongoConnected,
                name: 'MongoDB',
                host: mongoose.connection.host
            },
            server: {
                port: server.address()?.port || process.env.PORT || 4000,
                environment: process.env.NODE_ENV || 'development'
            }
        });
    } catch (error) {
        console.error('Health check failed:', error);
        res.status(500).json({
            status: 'error',
            message: 'Health check failed',
            timestamp: new Date().toISOString(),
            error: error.message
        });
    }
});

// Request logging with more details
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
    next();
});

// Auth middleware
const authenticate = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ 
            success: false, 
            message: 'No authentication token provided' 
        });
    }

    const token = authHeader.split(' ')[1];
    if (!token || !token.startsWith('test-token-')) {
        return res.status(401).json({ 
            success: false, 
            message: 'Invalid authentication token' 
        });
    }

    // For demo, set a mock user ID
    req.user = { _id: '1', email: 'tanmaytr05@gmail.com', name: 'Test User' };
    next();
};

// For development, using local MongoDB (with fallback for no MongoDB)
const MONGODB_URI = 'mongodb://127.0.0.1:27017/techpharma';
let dbConnected = false;

const connectToMongo = async () => {
    try {
        await mongoose.connect(MONGODB_URI, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            serverSelectionTimeoutMS: 5000,
        });
        dbConnected = true;
        console.log('Connected to MongoDB');
    } catch (err) {
        console.warn('MongoDB connection error:', err.message);
        console.log('Running in memory-only mode (no persistent storage)');
        dbConnected = false;
    }
}

// Try to connect but don't block server start
connectToMongo();

// Basic schemas
const UserSchema = new mongoose.Schema({
    email: String,
    name: String,
    role: String
});

const ProductSchema = new mongoose.Schema({
    name: String,
    price: Number,
    description: String,
    category: String
});

const OrderSchema = new mongoose.Schema({
    userId: String,
    products: Array,
    status: String,
    total: Number,
    createdAt: Date
});



// Models
const User = mongoose.model('User', UserSchema);
const Product = mongoose.model('Product', ProductSchema);
const Order = mongoose.model('Order', OrderSchema);


// Login endpoint
app.post('/api/auth/login', (req, res) => {
    const { email, password } = req.body;
    
    console.log('Login attempt:', { email });

    // Test credentials
    if (email === 'tanmaytr05@gmail.com' && password === 'tanmaytr0') {
        const response = {
            success: true,
            user: {
                _id: '1',
                email: email,
                name: 'Test User',
                role: 'user'
            },
            token: 'test-token-' + Date.now()
        };
        
        console.log('Login successful');
        return res.json(response);
    }

    return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
    });
});

// Analytics endpoint
app.get('/api/dashboard/analytics', authenticate, async (req, res) => {
    let dbConnected = mongoose.connection.readyState === 1;
    
    try {
        // Get stats data (using mock data if DB is not connected)
        const stats = {
            totalProducts: dbConnected ? await Product.countDocuments() : 5,
            productViews: 120,
            recentOrders: dbConnected ? await Order.countDocuments() : 8,
            revenue: 15000
        };

        // Get recent orders (using mock data if DB is not connected)
        const orders = dbConnected 
            ? await Order.find().sort({ createdAt: -1 }).limit(10).lean()
            : [
                {
                    _id: "order1",
                    user: "John Doe",
                    items: [
                        {
                            product: {
                                name: "Premium Medical Kit",
                                _id: "prod1"
                            },
                            quantity: 2,
                            price: 2000
                        }
                    ],
                    totalAmount: 4000,
                    status: "CONFIRMED",
                    createdAt: new Date().toISOString(),
                    paymentDetails: {
                        status: "PAID",
                        method: "CARD"
                    }
                }
            ];

        res.json({
            success: true,
            data: {
                stats,
                orders
            },
            mode: dbConnected ? 'database' : 'mock'
        });
    } catch (error) {
        console.error('Dashboard error:', error);
        // Send mock data on error as fallback
        res.json({
            success: true,
            data: {
                stats: {
                    totalProducts: 5,
                    productViews: 120,
                    recentOrders: 8,
                    revenue: 15000
                },
                orders: [
                    {
                        _id: "order1",
                        user: "John Doe",
                        items: [
                            {
                                product: {
                                    name: "Premium Medical Kit",
                                    _id: "prod1"
                                },
                                quantity: 2,
                                price: 2000
                            }
                        ],
                        totalAmount: 4000,
                        status: "CONFIRMED",
                        createdAt: new Date().toISOString(),
                        paymentDetails: {
                            status: "PAID",
                            method: "CARD"
                        }
                    }
                ]
            },
            mode: 'mock',
            error: error.message
        });
    }
});



// Products endpoint
app.get('/api/products', async (req, res) => {
    try {
        // Mock products data
        const products = [
            {
                id: '1',
                name: 'Product A',
                price: 99.99,
                description: 'High quality product'
            },
            {
                id: '2',
                name: 'Product B',
                price: 149.99,
                description: 'Premium product'
            }
        ];

        res.json(products);
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Error fetching products'
        });
    }
});

// Error handling
app.use((err, req, res, next) => {
    console.error('Server error:', err);
    res.status(500).json({
        success: false,
        message: 'Internal server error'
    });
});

// Get port from environment variable or use 5000 as default
const PORT = process.env.PORT || 5000;

// Start server directly on the specified port
app.listen(PORT, '0.0.0.0', () => {
    console.clear();
    console.log('='.repeat(50));
    console.log('Backend Server Running');
    console.log('-'.repeat(50));
    console.log(`• Port: ${PORT}`);
    console.log(`• Database: MongoDB`);
    console.log(`• URL: http://localhost:${PORT}`);
    console.log(`• Test Login:`);
    console.log(`  - Email: tanmaytr05@gmail.com`);
    console.log(`  - Password: tanmaytr0`);
    console.log('='.repeat(50));

    // Update frontend config with the port
    try {
        const fs = require('fs');
        const frontendConfigPath = '../frontend/lib/api-config.ts';
        if (fs.existsSync(frontendConfigPath)) {
            let config = fs.readFileSync(frontendConfigPath, 'utf8');
            config = config.replace(
                /const API_BASE_URL = ['"]http:\/\/localhost:\d+['"]/,
                `const API_BASE_URL = 'http://localhost:${PORT}'`
            );
            fs.writeFileSync(frontendConfigPath, config);
            console.log(`✓ Frontend API configuration updated to use port ${PORT}`);
        }
    } catch (error) {
        console.warn('Could not update frontend config:', error.message);
    }
});